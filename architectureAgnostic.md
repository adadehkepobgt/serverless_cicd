## Architecture-Agnostic Jenkins Pipeline

Here's the refined pipeline that works for ANY Lambda-based architecture:

```groovy
pipeline {
    agent any
    
    environment {
        AWS_DEFAULT_REGION = 'us-east-1'
        DEV_ACCOUNT = 'dev-account'
        S3_FRONTEND_BUCKET_DEV = 'euc-lambda-poc-frontend-dev'
    }
    
    tools {
        python 'Python3'
    }
    
    // Only run pipeline on dev branch
    when {
        branch 'dev'
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
                script {
                    env.GIT_COMMIT_SHORT = sh(
                        script: "git rev-parse --short HEAD",
                        returnStdout: true
                    ).trim()
                }
                echo "üîÄ Merged to dev branch - Running pipeline"
                echo "Building branch: ${env.BRANCH_NAME}"
                echo "Commit: ${env.GIT_COMMIT_SHORT}"
            }
        }
        
        stage('Install Dependencies') {
            steps {
                sh '''
                    echo "üì¶ Installing dependencies..."
                    
                    # Create virtual environment for backend
                    python3 -m venv venv
                    source venv/bin/activate
                    
                    # Upgrade pip
                    pip install --upgrade pip
                    
                    # Install backend Lambda dependencies
                    for lambda_dir in backend/lambdas/*/; do
                        if [ -f "$lambda_dir/requirements.txt" ]; then
                            echo "Installing dependencies for $lambda_dir"
                            pip install -r "$lambda_dir/requirements.txt"
                        fi
                    done
                    
                    # Install testing dependencies
                    pip install pytest boto3 moto pytest-html
                    
                    # Install frontend dependencies if frontend exists
                    if [ -d "frontend" ] && [ -f "frontend/package.json" ]; then
                        echo "Installing frontend dependencies..."
                        cd frontend
                        npm install
                        cd ..
                    fi
                '''
            }
        }
        
        stage('Build Frontend') {
            when {
                expression { fileExists('frontend') }
            }
            steps {
                sh '''
                    echo "üèóÔ∏è Building frontend..."
                    
                    # Build frontend assets if build tools are used
                    if [ -f "frontend/package.json" ]; then
                        echo "Running frontend build process..."
                        cd frontend
                        npm run build
                        cd ..
                    fi
                    
                    # Create standardized frontend deployment package
                    if [ -d "frontend/dist" ]; then
                        echo "Using frontend/dist/ as build output"
                        cp -r frontend/dist frontend-build/
                    elif [ -d "frontend/build" ]; then
                        echo "Using frontend/build/ as build output"
                        cp -r frontend/build frontend-build/
                    else
                        echo "Using frontend/ directory directly (static files)"
                        mkdir -p frontend-build
                        cp -r frontend/* frontend-build/ 2>/dev/null || true
                    fi
                    
                    echo "‚úÖ Frontend build completed"
                '''
            }
        }
        
        stage('Run Unit Tests') {
            steps {
                sh '''
                    echo "üß™ Running unit tests..."
                    
                    source venv/bin/activate
                    export PYTHONPATH="${WORKSPACE}/backend/lambdas:${PYTHONPATH}"
                    
                    # Run backend unit tests
                    python -m pytest tests/unit/ -v \
                        --junit-xml=unit-test-results.xml \
                        --html=unit-test-report.html \
                        --self-contained-html
                '''
            }
            post {
                always {
                    junit 'unit-test-results.xml'
                    publishHTML([
                        allowMissing: false,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: '.',
                        reportFiles: 'unit-test-report.html',
                        reportName: 'Unit Test Report'
                    ])
                }
            }
        }
        
        stage('Run Integration Tests') {
            steps {
                echo "üîó Running integration tests..."
                echo "‚ÑπÔ∏è  Integration tests are architecture-specific and test actual AWS service integrations"
                withCredentials([
                    [$class: 'AmazonWebServicesCredentialsBinding', 
                     credentialsId: 'aws-dev-account-credentials']
                ]) {
                    sh '''
                        source venv/bin/activate
                        export PYTHONPATH="${WORKSPACE}/backend/lambdas:${PYTHONPATH}"
                        
                        # Run integration tests against dev environment
                        # These tests should verify your specific architecture:
                        # - API Gateway endpoints (if using API Gateway)
                        # - S3 event processing (if using S3 triggers)
                        # - SQS message processing (if using queues)
                        # - DynamoDB operations (if using database)
                        # - Any other AWS service integrations
                        python -m pytest tests/integration/ -v \
                            --junit-xml=integration-test-results.xml \
                            --html=integration-test-report.html \
                            --self-contained-html
                    '''
                }
            }
            post {
                always {
                    junit 'integration-test-results.xml'
                    publishHTML([
                        allowMissing: false,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: '.',
                        reportFiles: 'integration-test-report.html',
                        reportName: 'Integration Test Report'
                    ])
                }
            }
        }
        
        stage('Deploy Frontend Assets') {
            when {
                expression { fileExists('frontend-build') }
            }
            steps {
                echo "üìÅ Deploying frontend assets to S3..."
                echo "‚ÑπÔ∏è  S3 is used as static file storage regardless of backend architecture"
                withCredentials([
                    [$class: 'AmazonWebServicesCredentialsBinding', 
                     credentialsId: 'aws-dev-account-credentials']
                ]) {
                    sh '''
                        # Deploy frontend assets to S3 (universal static file storage)
                        # This works for any architecture:
                        # - Direct S3 website hosting
                        # - CloudFront distribution source
                        # - Assets served by API Gateway
                        # - Resources loaded by any frontend framework
                        aws s3 sync frontend-build/ s3://${S3_FRONTEND_BUCKET_DEV}/ \
                            --delete \
                            --region ${AWS_DEFAULT_REGION}
                        
                        echo "‚úÖ Frontend assets deployed to S3"
                    '''
                }
            }
        }
        
        stage('Deploy Backend Functions') {
            steps {
                echo "‚ö° Deploying backend Lambda functions..."
                echo "‚ÑπÔ∏è  Lambda deployment is identical regardless of triggers or integrations"
                withCredentials([
                    [$class: 'AmazonWebServicesCredentialsBinding', 
                     credentialsId: 'aws-dev-account-credentials']
                ]) {
                    sh '''
                        # Deploy all Lambda functions found in backend/lambdas/
                        # This works for any Lambda integration pattern:
                        # - API Gateway ‚Üí Lambda
                        # - S3 Events ‚Üí Lambda  
                        # - SQS/SNS ‚Üí Lambda
                        # - EventBridge ‚Üí Lambda
                        # - Direct invocation
                        # - Application Load Balancer ‚Üí Lambda
                        # - Lambda ‚Üí Lambda
                        
                        for lambda_dir in backend/lambdas/*/; do
                            if [ -d "$lambda_dir" ]; then
                                lambda_name=$(basename $lambda_dir)
                                echo "üì¶ Packaging and deploying $lambda_name"
                                
                                # Create clean deployment package
                                cd $lambda_dir
                                zip -r ../../${lambda_name}-dev.zip . \
                                    -x "*.pyc" "*__pycache__*" "tests/*" "*.md" ".git*" "*.DS_Store"
                                cd ../..
                                
                                # Update Lambda function code
                                aws lambda update-function-code \
                                    --function-name ${lambda_name}-dev \
                                    --zip-file fileb://${lambda_name}-dev.zip \
                                    --region ${AWS_DEFAULT_REGION}
                                
                                echo "‚úÖ ${lambda_name}-dev updated successfully"
                            fi
                        done
                    '''
                }
            }
        }
        
        stage('Verify Deployment Success') {
            steps {
                echo "üîç Verifying deployment success..."
                echo "‚ÑπÔ∏è  Checking deployment status, not testing integrations"
                withCredentials([
                    [$class: 'AmazonWebServicesCredentialsBinding', 
                     credentialsId: 'aws-dev-account-credentials']
                ]) {
                    sh '''
                        echo "üìÅ Frontend Assets Status:"
                        if aws s3 ls s3://${S3_FRONTEND_BUCKET_DEV}/ >/dev/null 2>&1; then
                            aws s3 ls s3://${S3_FRONTEND_BUCKET_DEV}/ --recursive --human-readable --summarize
                            echo "‚úÖ Frontend assets successfully deployed"
                        else
                            echo "‚ÑπÔ∏è  No frontend assets found (API-only architecture)"
                        fi
                        
                        echo ""
                        echo "‚ö° Lambda Function Deployment Status:"
                        for lambda_dir in backend/lambdas/*/; do
                            if [ -d "$lambda_dir" ]; then
                                lambda_name=$(basename $lambda_dir)
                                echo "Checking ${lambda_name}-dev deployment status..."
                                
                                aws lambda get-function \
                                    --function-name ${lambda_name}-dev \
                                    --region ${AWS_DEFAULT_REGION} \
                                    --query 'Configuration.[FunctionName,LastModified,State,Runtime]' \
                                    --output table
                            fi
                        done
                        
                        echo ""
                        echo "‚úÖ All deployments verified successfully"
                        echo "‚ÑπÔ∏è  Integration testing validates that deployed components work together"
                    '''
                }
            }
        }
    }
    
    post {
        always {
            sh '''
                echo "üßπ Cleaning up build artifacts..."
                rm -rf venv || true
                rm -f *.zip || true
                rm -rf frontend-build || true
                rm -rf node_modules || true
            '''
        }
        success {
            script {
                def hasFrontend = fileExists('frontend')
                def frontendMessage = hasFrontend ? 
                    "‚úÖ Frontend assets deployed to S3" : 
                    "‚ÑπÔ∏è  No frontend (API-only architecture)"
                
                echo """
üéâ DEV DEPLOYMENT COMPLETED SUCCESSFULLY!

üìã Summary:
‚úÖ Unit tests passed (Lambda logic verified)
‚úÖ Integration tests passed (Architecture verified)
${frontendMessage}
‚úÖ Backend Lambda functions updated
‚úÖ All deployments verified

üåê Dev Environment Ready:
${hasFrontend ? "Frontend: https://${env.S3_FRONTEND_BUCKET_DEV}.s3.${env.AWS_DEFAULT_REGION}.amazonaws.com" : ""}
Backend: Lambda functions active in dev account

üèóÔ∏è Architecture Support:
This pipeline works with any Lambda-based architecture:
- API Gateway + Lambda
- Event-driven (S3, SQS, SNS, EventBridge)
- Serverless web applications  
- Microservices
- Data processing pipelines

üöÄ Next Steps:
1. Test your specific architecture in dev environment
2. Verify all integrations work as expected
3. Ready for CCB review when needed
                """
            }
        }
        failure {
            echo '''
‚ùå DEV DEPLOYMENT FAILED!

üîß Troubleshooting Steps:
1. Check console output above for specific errors
2. Common issues:
   - Unit test failures: Fix Lambda function logic
   - Integration test failures: Check AWS service configurations
   - AWS permissions: Verify aws-dev-account-credentials
   - Lambda packaging: Check requirements.txt files
   - Missing AWS resources: Ensure Lambda functions and S3 bucket exist

üîÑ To retry:
Push another commit to dev branch to trigger pipeline again

üí° Architecture-specific debugging:
- API Gateway: Check endpoint configurations and Lambda triggers
- Event-driven: Verify event source mappings and permissions
- S3: Check bucket policies and event configurations
- SQS/SNS: Verify queue/topic permissions and Lambda subscriptions
            '''
        }
        unstable {
            echo '''
‚ö†Ô∏è DEPLOYMENT COMPLETED WITH WARNINGS

Some tests may have failed but deployment proceeded.
Check test reports for details.

üîç Common causes:
- Integration tests failed (architecture-specific issues)
- Flaky tests due to AWS service latency
- Partial functionality not yet implemented
            '''
        }
    }
}
```

---

## **Key Architecture-Agnostic Improvements**

### **1. Conditional Frontend Handling**
```groovy
when {
    expression { fileExists('frontend') }
}
```
- **API-only projects**: Skip frontend stages entirely
- **Web applications**: Process frontend normally

### **2. Universal Lambda Deployment**
```groovy
# Works for ANY Lambda trigger:
aws lambda update-function-code \
    --function-name ${lambda_name}-dev \
    --zip-file fileb://${lambda_name}-dev.zip
```
- **API Gateway**: Lambda functions serve HTTP requests
- **S3 Events**: Lambda functions process file uploads
- **SQS**: Lambda functions process queue messages
- **EventBridge**: Lambda functions handle custom events

### **3. Architecture-Aware Messaging**
```groovy
echo "‚ÑπÔ∏è  Integration tests are architecture-specific and test actual AWS service integrations"
```
- **Clear documentation** of what each stage does
- **Explains responsibility** for integration tests

### **4. Flexible Verification**
```groovy
if aws s3 ls s3://${S3_FRONTEND_BUCKET_DEV}/ >/dev/null 2>&1; then
    # Frontend exists
else
    echo "‚ÑπÔ∏è  No frontend assets found (API-only architecture)"
fi
```
- **Handles both**: Web apps and pure APIs
- **No failures**: If frontend doesn't exist

### **5. Smart Success Messages**
```groovy
def hasFrontend = fileExists('frontend')
def frontendMessage = hasFrontend ? 
    "‚úÖ Frontend assets deployed to S3" : 
    "‚ÑπÔ∏è  No frontend (API-only architecture)"
```
- **Dynamic messaging** based on project structure
- **Relevant information** for each architecture type

---

## **Supported Architectures (Same Pipeline)**

### **API Gateway + Lambda**
```
tests/integration/test_api_endpoints.py
‚Üí Tests HTTP endpoints and responses
```

### **Event-Driven Processing**
```
tests/integration/test_s3_processing.py
‚Üí Tests file upload triggers and processing
```

### **Microservices**
```
tests/integration/test_service_communication.py
‚Üí Tests Lambda-to-Lambda communication
```

### **Data Pipelines**
```
tests/integration/test_data_flow.py
‚Üí Tests data transformation and storage
```

**The pipeline code never changes - only the integration tests adapt to your specific architecture!**


## Repository Structure for Architecture-Agnostic Pipeline

### **Complete Repository Structure**

```
euc-lambda-poc/
‚îú‚îÄ‚îÄ Jenkinsfile                           # Jenkins pipeline configuration
‚îú‚îÄ‚îÄ README.md                             # Project documentation
‚îú‚îÄ‚îÄ .gitignore                            # Git ignore patterns
‚îú‚îÄ‚îÄ requirements-dev.txt                  # Development dependencies (optional)
‚îú‚îÄ‚îÄ 
‚îú‚îÄ‚îÄ frontend/                             # Frontend assets (conditional)
‚îÇ   ‚îú‚îÄ‚îÄ index.html                        # Main HTML file
‚îÇ   ‚îú‚îÄ‚îÄ styles.css                        # CSS styles
‚îÇ   ‚îú‚îÄ‚îÄ app.js                           # JavaScript application
‚îÇ   ‚îú‚îÄ‚îÄ assets/                          # Static assets
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ images/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ fonts/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ icons/
‚îÇ   ‚îú‚îÄ‚îÄ package.json                     # Frontend build dependencies (optional)
‚îÇ   ‚îú‚îÄ‚îÄ package-lock.json                # Dependency lock file (if using npm)
‚îÇ   ‚îî‚îÄ‚îÄ webpack.config.js                # Build configuration (if using webpack)
‚îÇ   
‚îú‚îÄ‚îÄ backend/                             # Backend Lambda functions
‚îÇ   ‚îî‚îÄ‚îÄ lambdas/                         # All Lambda functions
‚îÇ       ‚îú‚îÄ‚îÄ user-authentication/         # Individual Lambda function
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ lambda_function.py       # Main handler
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt         # Function dependencies
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ helpers.py               # Supporting modules
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ config.py                # Configuration
‚îÇ       ‚îú‚îÄ‚îÄ data-processor/              # Another Lambda function
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ lambda_function.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ data_utils.py
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ models.py
‚îÇ       ‚îú‚îÄ‚îÄ api-gateway-handler/         # API Gateway Lambda
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ lambda_function.py
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ routes.py
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ middleware.py
‚îÇ       ‚îî‚îÄ‚îÄ notification-service/        # Event-driven Lambda
‚îÇ           ‚îú‚îÄ‚îÄ lambda_function.py
‚îÇ           ‚îú‚îÄ‚îÄ requirements.txt
‚îÇ           ‚îî‚îÄ‚îÄ email_templates.py
‚îÇ
‚îú‚îÄ‚îÄ tests/                               # All test files
‚îÇ   ‚îú‚îÄ‚îÄ unit/                           # Unit tests (architecture-agnostic)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test_user_authentication.py  # Test Lambda logic
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test_data_processor.py       # Test data processing
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test_api_handler.py          # Test API logic
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ test_notification_service.py # Test notification logic
‚îÇ   ‚îú‚îÄ‚îÄ integration/                    # Integration tests (architecture-specific)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test_api_endpoints.py       # API Gateway integration
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test_s3_processing.py       # S3 event integration
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test_notification_flow.py   # SNS/SQS integration
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ test_end_to_end.py          # Full workflow tests
‚îÇ   ‚îú‚îÄ‚îÄ fixtures/                       # Test data and fixtures
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sample_data.json
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test_files/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ mock_responses.py
‚îÇ   ‚îî‚îÄ‚îÄ conftest.py                     # Pytest configuration
‚îÇ
‚îú‚îÄ‚îÄ infrastructure/                     # Infrastructure as Code (optional)
‚îÇ   ‚îú‚îÄ‚îÄ cloudformation/                 # CloudFormation templates
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lambda-functions.yaml
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api-gateway.yaml
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ s3-buckets.yaml
‚îÇ   ‚îú‚îÄ‚îÄ terraform/                      # Terraform configurations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.tf
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ variables.tf
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ outputs.tf
‚îÇ   ‚îî‚îÄ‚îÄ serverless.yml                  # Serverless Framework (alternative)
‚îÇ
‚îú‚îÄ‚îÄ docs/                               # Documentation
‚îÇ   ‚îú‚îÄ‚îÄ api/                           # API documentation
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ endpoints.md
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ authentication.md
‚îÇ   ‚îú‚îÄ‚îÄ architecture.md                # Architecture overview
‚îÇ   ‚îú‚îÄ‚îÄ deployment.md                  # Deployment instructions
‚îÇ   ‚îî‚îÄ‚îÄ testing.md                     # Testing guidelines
‚îÇ
‚îî‚îÄ‚îÄ scripts/                           # Utility scripts
    ‚îú‚îÄ‚îÄ deploy-local.sh                # Local deployment script
    ‚îú‚îÄ‚îÄ run-tests.sh                   # Test runner script
    ‚îî‚îÄ‚îÄ setup-dev-env.sh               # Development setup
```

---

## **Architecture-Specific Examples**

### **Example 1: API Gateway Architecture**

```
euc-lambda-poc/
‚îú‚îÄ‚îÄ Jenkinsfile
‚îú‚îÄ‚îÄ frontend/                          # React/Vue web app
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ public/
‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îî‚îÄ‚îÄ build/                         # Generated by npm run build
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îî‚îÄ‚îÄ lambdas/
‚îÇ       ‚îú‚îÄ‚îÄ users-api/                 # GET/POST /users
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ lambda_function.py
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ requirements.txt
‚îÇ       ‚îú‚îÄ‚îÄ products-api/              # GET/POST /products  
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ lambda_function.py
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ requirements.txt
‚îÇ       ‚îú‚îÄ‚îÄ orders-api/                # GET/POST /orders
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ lambda_function.py
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ requirements.txt
‚îÇ       ‚îî‚îÄ‚îÄ auth-api/                  # POST /login, /register
‚îÇ           ‚îú‚îÄ‚îÄ lambda_function.py
‚îÇ           ‚îî‚îÄ‚îÄ requirements.txt
‚îî‚îÄ‚îÄ tests/
    ‚îú‚îÄ‚îÄ unit/                          # Test individual Lambda logic
    ‚îî‚îÄ‚îÄ integration/
        ‚îî‚îÄ‚îÄ test_api_endpoints.py      # Test actual API Gateway endpoints
```

**Integration Test Example:**
```python
# tests/integration/test_api_endpoints.py
import requests
import pytest

def test_users_api():
    response = requests.get('https://your-api.execute-api.us-east-1.amazonaws.com/dev/users')
    assert response.status_code == 200
    assert 'users' in response.json()

def test_auth_api():
    response = requests.post('https://your-api.execute-api.us-east-1.amazonaws.com/dev/login',
                           json={'username': 'test', 'password': 'test'})
    assert response.status_code in [200, 401]
```

### **Example 2: Event-Driven Architecture**

```
euc-lambda-poc/
‚îú‚îÄ‚îÄ Jenkinsfile
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îî‚îÄ‚îÄ lambdas/
‚îÇ       ‚îú‚îÄ‚îÄ s3-file-processor/         # Triggered by S3 uploads
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ lambda_function.py
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ requirements.txt
‚îÇ       ‚îú‚îÄ‚îÄ order-queue-processor/     # Triggered by SQS messages
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ lambda_function.py
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ requirements.txt
‚îÇ       ‚îú‚îÄ‚îÄ email-notification/        # Triggered by SNS events
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ lambda_function.py
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ requirements.txt
‚îÇ       ‚îî‚îÄ‚îÄ data-sync/                 # Triggered by DynamoDB streams
‚îÇ           ‚îú‚îÄ‚îÄ lambda_function.py
‚îÇ           ‚îî‚îÄ‚îÄ requirements.txt
‚îî‚îÄ‚îÄ tests/
    ‚îú‚îÄ‚îÄ unit/                          # Test Lambda logic
    ‚îî‚îÄ‚îÄ integration/
        ‚îú‚îÄ‚îÄ test_s3_processing.py      # Test S3 event processing
        ‚îú‚îÄ‚îÄ test_queue_processing.py   # Test SQS message processing
        ‚îî‚îÄ‚îÄ test_notification_flow.py  # Test SNS notifications
```

**Integration Test Example:**
```python
# tests/integration/test_s3_processing.py
import boto3
import time

def test_s3_file_processing():
    s3 = boto3.client('s3')
    
    # Upload test file to trigger Lambda
    s3.put_object(
        Bucket='input-bucket-dev',
        Key='test-file.csv',
        Body=b'name,age\nJohn,25\nJane,30'
    )
    
    # Wait for processing
    time.sleep(10)
    
    # Verify processed file exists
    response = s3.list_objects_v2(
        Bucket='output-bucket-dev',
        Prefix='processed-test-file'
    )
    assert response['KeyCount'] > 0
```

### **Example 3: Pure API Backend (No Frontend)**

```
euc-lambda-poc/
‚îú‚îÄ‚îÄ Jenkinsfile
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îî‚îÄ‚îÄ lambdas/
‚îÇ       ‚îî‚îÄ‚îÄ graphql-api/               # Single GraphQL endpoint
‚îÇ           ‚îú‚îÄ‚îÄ lambda_function.py
‚îÇ           ‚îú‚îÄ‚îÄ requirements.txt
‚îÇ           ‚îú‚îÄ‚îÄ schema.py
‚îÇ           ‚îî‚îÄ‚îÄ resolvers.py
‚îî‚îÄ‚îÄ tests/
    ‚îú‚îÄ‚îÄ unit/
    ‚îÇ   ‚îî‚îÄ‚îÄ test_graphql_logic.py
    ‚îî‚îÄ‚îÄ integration/
        ‚îî‚îÄ‚îÄ test_graphql_api.py        # Test GraphQL queries/mutations
```

### **Example 4: Microservices Architecture**

```
euc-lambda-poc/
‚îú‚îÄ‚îÄ Jenkinsfile
‚îú‚îÄ‚îÄ frontend/                          # Admin dashboard
‚îÇ   ‚îú‚îÄ‚îÄ index.html
‚îÇ   ‚îî‚îÄ‚îÄ app.js
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îî‚îÄ‚îÄ lambdas/
‚îÇ       ‚îú‚îÄ‚îÄ user-service/              # User management microservice
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ lambda_function.py
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ requirements.txt
‚îÇ       ‚îú‚îÄ‚îÄ inventory-service/         # Inventory microservice
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ lambda_function.py
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ requirements.txt
‚îÇ       ‚îú‚îÄ‚îÄ order-service/             # Order processing microservice
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ lambda_function.py
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ requirements.txt
‚îÇ       ‚îî‚îÄ‚îÄ notification-service/      # Notification microservice
‚îÇ           ‚îú‚îÄ‚îÄ lambda_function.py
‚îÇ           ‚îî‚îÄ‚îÄ requirements.txt
‚îî‚îÄ‚îÄ tests/
    ‚îú‚îÄ‚îÄ unit/                          # Test each service logic
    ‚îî‚îÄ‚îÄ integration/
        ‚îî‚îÄ‚îÄ test_service_communication.py  # Test inter-service communication
```

---

## **Key Files Explained**

### **Jenkinsfile (Required)**
```groovy
# The architecture-agnostic pipeline we created
# Works with any of the above structures
```

### **requirements.txt (Per Lambda)**
```txt
# backend/lambdas/user-authentication/requirements.txt
boto3==1.26.137
bcrypt==4.0.1
jwt==1.3.1
requests==2.31.0
```

### **Frontend package.json (Optional)**
```json
{
  "name": "euc-lambda-poc-frontend",
  "version": "1.0.0",
  "scripts": {
    "build": "webpack --mode production",
    "dev": "webpack serve --mode development"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "webpack": "^5.88.0",
    "webpack-cli": "^5.1.4"
  }
}
```

### **Sample Lambda Function**
```python
# backend/lambdas/user-authentication/lambda_function.py
import json
import boto3

def lambda_handler(event, context):
    """
    Architecture-agnostic Lambda function
    Can be triggered by:
    - API Gateway (HTTP requests)
    - S3 Events (file uploads)
    - SQS Messages (queue processing)
    - Direct invocation
    """
    
    # Your business logic here
    result = process_request(event)
    
    return {
        'statusCode': 200,
        'body': json.dumps(result)
    }

def process_request(event):
    # Business logic implementation
    return {'message': 'Success'}
```

### **.gitignore**
```
# Python
__pycache__/
*.pyc
*.pyo
venv/
.pytest_cache/

# Frontend
node_modules/
dist/
build/
*.log

# IDE
.vscode/
.idea/
*.swp

# AWS
.aws/

# Jenkins
*.zip
frontend-build/

# OS
.DS_Store
Thumbs.db
```

---

## **Pipeline Compatibility Matrix**

| Architecture | Frontend | Backend | Pipeline Changes |
|-------------|----------|---------|------------------|
| **API Gateway + React** | ‚úÖ frontend/ | ‚úÖ backend/lambdas/ | None |
| **Event-Driven Processing** | ‚ùå No frontend | ‚úÖ backend/lambdas/ | None |
| **Microservices** | ‚úÖ frontend/ | ‚úÖ backend/lambdas/ | None |
| **Pure API Backend** | ‚ùå No frontend | ‚úÖ backend/lambdas/ | None |
| **Serverless Web App** | ‚úÖ frontend/ | ‚úÖ backend/lambdas/ | None |

**The pipeline automatically adapts to whatever structure you have!**

---

## **Getting Started**

### **Step 1: Choose Your Architecture**
Pick one of the examples above that matches your use case

### **Step 2: Create Repository Structure**
```bash
mkdir euc-lambda-poc
cd euc-lambda-poc

# Create basic structure
mkdir -p backend/lambdas
mkdir -p tests/{unit,integration}
mkdir -p frontend  # If you have frontend

# Add Jenkinsfile
# (Copy the architecture-agnostic pipeline we created)
```

### **Step 3: Add Your Lambda Functions**
```bash
# For each Lambda function:
mkdir backend/lambdas/your-function-name
# Add lambda_function.py and requirements.txt
```

### **Step 4: Add Tests**
```bash
# Unit tests (test Lambda logic)
# Integration tests (test your specific architecture)
```

**The pipeline will automatically discover and deploy everything!**
